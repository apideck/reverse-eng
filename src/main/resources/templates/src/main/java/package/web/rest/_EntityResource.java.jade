package {{packageName}}.web.rest;

import com.codahale.metrics.annotation.Timed;
import {{packageName}}.domain.{{entityClass}};
import {{packageName}}.repository.{{entityClass}}Repository
import {{packageName}}.web.rest.util.HeaderUtil;
import {{packageName}}.web.rest.util.PaginationUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import javax.inject.Inject;
import javax.validation.Valid;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;

/**
 * REST controller for managing {{entityClass}}.
 */
@RestController
@RequestMapping("/api")
public class {{ entityClass}}Resource {

    private final Logger log = LoggerFactory.getLogger({{ entityClass }}Resource.class);

    @Inject
    private {{ entityClass }}Repository {{ entityInstance }}Repository;

    /**
     * POST  /{{ entityInstance }}s -> Create a new {{ entityInstance }}.
     */
    @RequestMapping(value = "/{{entityInstance}}s",
            method = RequestMethod.POST,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed<%
    var instanceType = (dto == 'mapstruct') ? entityClass + 'DTO' : entityClass;
    var instanceName = (dto == 'mapstruct') ? entityInstance + 'DTO' : entityInstance;
    var mapper = entityInstance  + 'Mapper';
    var dtoToEntity = mapper + '.'+ entityInstance +'DTOTo' + entityClass;
    var entityToDto = mapper + '.'+ entityInstance +'To' + entityClass + 'DTO';
    }}
    public ResponseEntity<{{entityClass}}> create(<% if (validation) { }}@Valid <% } }}@RequestBody {{ instanceType }} {{ instanceName }}) throws URISyntaxException {
        log.debug("REST request to save {{ entityClass }} : {}", {{ instanceName }});
        if ({{ instanceName }}.getId() != null) {
            return ResponseEntity.badRequest().header("Failure", "A new {{ entityInstance }} cannot already have an ID").body(null);
        }<% if (dto == 'mapstruct') { }}
        {{ entityClass }} {{ entityInstance }} = {{ dtoToEntity }}({{ instanceName }});<% } }}
        {{ entityClass }} result = {{ entityInstance }}Repository.save({{ entityInstance }});<% if (searchEngine == 'elasticsearch') { }}
        {{ entityInstance }}SearchRepository.save(result);<% } }}
        return ResponseEntity.created(new URI("/api/{{ entityInstance }}s/" + result.getId()))
                .headers(HeaderUtil.createEntityCreationAlert("{{ entityInstance }}", result.getId().toString()))
                .body(<% if (dto == 'mapstruct') { }}{{ entityToDto }}(result)<% } else { }}result<% } }});
    }

    /**
     * PUT  /{{ entityInstance }}s -> Updates an existing {{ entityInstance }}.
     */
    @RequestMapping(value = "/{{entityInstance}}s",
        method = RequestMethod.PUT,
        produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    public ResponseEntity<{{entityClass}}> update(<% if (validation) { }}@Valid <% } }}@RequestBody {{ instanceType }} {{ instanceName }}) throws URISyntaxException {
        log.debug("REST request to update {{ entityClass }} : {}", {{ instanceName }});
        if ({{ instanceName }}.getId() == null) {
            return create({{ instanceName }});
        }<% if (dto == 'mapstruct') { }}
        {{ entityClass }} {{ entityInstance }} = {{ entityInstance }}Mapper.{{ entityInstance }}DTOTo{{ entityClass }}({{ instanceName }});<% } }}
        {{ entityClass }} result = {{ entityInstance }}Repository.save({{ entityInstance }});<% if (searchEngine == 'elasticsearch') { }}
        {{ entityInstance }}SearchRepository.save({{ entityInstance }});<% } }}
        return ResponseEntity.ok()
                .headers(HeaderUtil.createEntityUpdateAlert("{{ entityInstance }}", {{ instanceName }}.getId().toString()))
                .body(<% if (dto == 'mapstruct') { }}{{ entityToDto }}(result)<% } else { }}result<% } }});
    }

    /**
     * GET  /{{entityInstance}}s -> get all the {{ entityInstance }}s.
     */
    @RequestMapping(value = "/{{entityInstance}}s",
            method = RequestMethod.GET,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed<% if (dto == 'mapstruct') { }}
    @Transactional(readOnly = true)<% } }}<% if (pagination == 'no') { }}
    public List<{{ entityClass }}<% if (dto == 'mapstruct') { }}DTO<% } }}> getAll(<% if (fieldsContainNoOwnerOneToOne == true) { }}@RequestParam(required = false) String filter<% } }}) {<% for (idx in relationships) { if (relationships[idx].relationshipType == 'one-to-one' && relationships[idx].ownerSide != true) { }}
        if ("{{ relationships[idx].relationshipName.toLowerCase() }}-is-null".equals(filter)) {
            log.debug("REST request to get all {{ entityClass }}s where {{ relationships[idx].relationshipName }} is null");<% if (javaVersion == '7') { }}
            List {{ entityInstance }}s = new ArrayList<{{ entityClass }}>();
            for ({{ entityClass }} {{ entityInstance }} : {{ entityInstance }}Repository.findAll()) {
                if ({{ entityInstance }}.get{{ relationships[idx].relationshipNameCapitalized }}() == null) {
                    {{ entityInstance }}s.add({{ entityInstance }});
                }
            }
            return {{ entityInstance }}s;<% } else { }}
            return StreamSupport
                .stream({{ entityInstance }}Repository.findAll().spliterator(), false)
                .filter({{ entityInstance }} -> {{ entityInstance }}.get{{ relationships[idx].relationshipNameCapitalized }}() == null)<% if (dto == 'mapstruct') { }}
                .map({{ entityInstance }} -> {{ entityInstance }}Mapper.{{ entityInstance }}To{{ entityClass }}DTO({{ entityInstance }}))
                .collect(Collectors.toCollection(LinkedList::new));<% } else { }}
                .collect(Collectors.toList());<% } }}<% } }}
        }
<% } } }}
        log.debug("REST request to get all {{ entityClass }}s");
        return {{ entityInstance }}Repository.findAll()<% if (dto == 'mapstruct') { }}.stream()
            .map({{ entityInstance }} -> {{ entityInstance }}Mapper.{{ entityInstance }}To{{ entityClass }}DTO({{ entityInstance }}))
            .collect(Collectors.toCollection(LinkedList::new))<% } }};<% } }}<% if (pagination != 'no') { }}
    public ResponseEntity<List<{{ entityClass }}<% if (dto == 'mapstruct') { }}DTO<% } }}>> getAll(@RequestParam(value = "page" , required = false) Integer offset,
                                  @RequestParam(value = "per_page", required = false) Integer limit)
        throws URISyntaxException {
        Page<{{entityClass}}> page = {{ entityInstance }}Repository.findAll(PaginationUtil.generatePageRequest(offset, limit));
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(page, "/api/{{ entityInstance }}s", offset, limit);
        return new ResponseEntity<<% if (javaVersion == '7') { }}List<{{ entityClass }}><% } }}>(page.getContent()<% if (dto == 'mapstruct') { }}.stream()
            .map({{ entityInstance }}Mapper::{{ entityInstance }}To{{ entityClass }}DTO)
            .collect(Collectors.toCollection(LinkedList::new))<% } }}, headers, HttpStatus.OK);<% } }}
    }

    /**
     * GET  /{{entityInstance}}s/:id -> get the "id" {{entityInstance}}.
     */
    @RequestMapping(value = "/{{entityInstance}}s/{id}",
            method = RequestMethod.GET,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    public get(@PathVariable java.lang.Long id): ResponseEntity[{{entityClass}}] {
        log.debug("REST request to get {{entityClass}} : {}", id);
        Option({{entityInstance}}Repository.findOne(id))
            .map({{entityInstance}} -> new ResponseEntity[_]({{entityInstance}}, HttpStatus.OK))
            .orElse(new ResponseEntity[_](HttpStatus.NOT_FOUND))
    }

    /**
     * DELETE  /{{ entityInstance }}s/:id -> delete the "id" {{ entityInstance }}.
     */
    @RequestMapping(value = "/{{entityInstance}}s/{id}",
            method = RequestMethod.DELETE,
            produces = MediaType.APPLICATION_JSON_VALUE)
    @Timed
    def delete(@PathVariable id: java.lang.Long): ResponseEntity[Void] {
    	log.debug("REST request to delete {{ entityClass }} : {}", id)
    	{{ entityInstance }}Repository.delete(id)
    	ResponseEntity.ok.headers(HeaderUtil.createEntityDeletionAlert("{{entityInstance}}", id.toString)).build;
  	}

}
